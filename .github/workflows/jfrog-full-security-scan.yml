name: "JFrog OIDC CI Workflow with Full Security Scan"

on: push

permissions:
  id-token: write
  contents: read

env:
  # Your full file (kept for reference; not used for the fast install)
  REQS_FILE: langgraph/network-security-agent/setup/requirements.txt
  # Optional tiny file you can add to the repo for fast installs (e.g., requests==2.19.1)
  REQS_FAST_FILE: .jfrog/fast-requirements.txt
  BUILD_NAME: jfrog-security-scan-build
  BUILD_NUMBER: ${{ github.run_id }}
  GENERIC_REPO: ${{ vars.GENERIC_REPO }}

jobs:
  build-scan-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Setup JFrog CLI (OIDC)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}
        with:
          oidc-provider-name: github-oidc-integration

      - name: Ensure jq is available
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      - name: "Sanity: show PyPI virtual repo details"
        shell: bash
        run: |
          set -euo pipefail
          KEY="${{ vars.PYPI_VIRTUAL_REPO }}"
          echo "Using PYPI_VIRTUAL_REPO=$KEY"
          jf rt curl -s -XGET "/api/repositories/$KEY" | jq '{key,packageType,type,repositories,defaultDeploymentRepo}'
          {
            echo "### JFrog Settings"
            echo "- **JF_URL**: \`${{ vars.JF_URL }}\`"
            echo "- **PYPI_VIRTUAL_REPO**: \`$KEY\`"
            echo "- **GENERIC_REPO**: \`${GENERIC_REPO}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      # --- Source/Secrets/IaC scan (no install) ---
      - name: Scan repository (non-blocking)
        shell: bash
        run: |
          jf scan . --fail=false --format table

      # --- Refresh OIDC so we start installs with a fresh token ---
      - name: Re-authenticate JFrog CLI (refresh OIDC)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}
        with:
          oidc-provider-name: github-oidc-integration

      # --- Configure pip to resolve via JFrog ---
      - name: Configure pip to resolve via JFrog
        shell: bash
        run: |
          SERVER_ID="${SETUP_JFROG_CLI_SERVER_IDS:-setup-jfrog-cli-server}"
          jf pip-config \
            --repo-resolve "${{ vars.PYPI_VIRTUAL_REPO }}" \
            --server-id-resolve "$SERVER_ID"

      # --- Avoid pip probing /simple/pip/ (prevents 401 chatter) ---
      - name: Disable pip self version check
        shell: bash
        run: echo "PIP_DISABLE_PIP_VERSION_CHECK=1" >> "$GITHUB_ENV"

      # --- FAST install to capture a CVE into build-info (minimal deps) ---
      # If .jfrog/fast-requirements.txt exists, use it. Otherwise, just install requests==2.19.1 with --no-deps.
      - name: Install deps via JFrog CLI (fast capture)
        shell: bash
        run: |
          set -euo pipefail
          FAST="$GITHUB_WORKSPACE/$REQS_FAST_FILE"
          pip uninstall -y requests urllib3 PyYAML || true
          if [ -f "$FAST" ]; then
            echo "Using fast requirements file: $FAST"
            cat "$FAST"
            jf pip install -r "$FAST" \
              --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          else
            echo "No fast file found; installing a minimal vulnerable package only."
            jf pip install "requests==2.19.1" --no-deps \
              --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          fi
          echo "Installed packages snapshot:"; pip freeze | egrep 'requests|urllib3|PyYAML' || true

      # --- Upload repository artifacts (attach to the same build) ---
      - name: Upload repository artifacts
        shell: bash
        run: |
          echo "Uploading source code as artifacts to $GENERIC_REPO..."
          jf rt u "**/*" "$GENERIC_REPO/" --flat=false \
            --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      # --- Publish & Scan the build (non-blocking) ---
      - name: Publish build info
        shell: bash
        run: jf rt bp "$BUILD_NAME" "$BUILD_NUMBER"

      - name: Scan published build (non-blocking)
        shell: bash
        run: jf bs "$BUILD_NAME" "$BUILD_NUMBER" --fail=false
